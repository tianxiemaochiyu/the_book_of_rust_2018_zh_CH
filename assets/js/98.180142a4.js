(window.webpackJsonp=window.webpackJsonp||[]).push([[98],{577:function(t,s,a){"use strict";a.r(s);var e=a(4),n=Object(e.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"面向对象语言的特征"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#面向对象语言的特征"}},[t._v("#")]),t._v(" 面向对象语言的特征")]),t._v(" "),a("blockquote",[a("p",[a("a",{attrs:{href:"https://github.com/rust-lang/book/blob/master/src/ch17-01-what-is-oo.md",target:"_blank",rel:"noopener noreferrer"}},[t._v("ch17-01-what-is-oo.md"),a("OutboundLink")],1),t._v(" "),a("br"),t._v("\ncommit 34caca254c3e08ff9fe3ad985007f45e92577c03")])]),t._v(" "),a("p",[t._v("关于一个语言被称为面向对象所需的功能，在编程社区内并未达成一致意见。Rust 被很多不同的编程范式影响，包括面向对象编程；比如第十三章提到了来自函数式编程的特性。面向对象编程语言所共享的一些特性往往是对象、封装和继承。让我们看一下这每一个概念的含义以及 Rust 是否支持他们。")]),t._v(" "),a("h3",{attrs:{id:"对象包含数据和行为"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#对象包含数据和行为"}},[t._v("#")]),t._v(" 对象包含数据和行为")]),t._v(" "),a("p",[t._v("由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides（Addison-Wesley Professional, 1994）编写的书 "),a("em",[t._v("Design Patterns: Elements of Reusable Object-Oriented Software")]),t._v(" 被俗称为 "),a("em",[t._v("The Gang of Four")]),t._v(" (字面意思为“四人帮”)，它是面向对象编程模式的目录。它这样定义面向对象编程：")]),t._v(" "),a("blockquote",[a("p",[t._v("Object-oriented programs are made up of objects. An "),a("em",[t._v("object")]),t._v(" packages both\ndata and the procedures that operate on that data. The procedures are\ntypically called "),a("em",[t._v("methods")]),t._v(" or "),a("em",[t._v("operations")]),t._v(".")]),t._v(" "),a("p",[t._v("面向对象的程序是由对象组成的。一个 "),a("strong",[t._v("对象")]),t._v(" 包含数据和操作这些数据的过程。这些过程通常被称为 "),a("strong",[t._v("方法")]),t._v(" 或 "),a("strong",[t._v("操作")]),t._v("。")])]),t._v(" "),a("p",[t._v("在这个定义下，Rust 是面向对象的：结构体和枚举包含数据而 "),a("code",[t._v("impl")]),t._v(" 块提供了在结构体和枚举之上的方法。虽然带有方法的结构体和枚举并不被 "),a("strong",[t._v("称为")]),t._v(" 对象，但是他们提供了与对象相同的功能，参考 "),a("em",[t._v("The Gang of Four")]),t._v(" 中对象的定义。")]),t._v(" "),a("h3",{attrs:{id:"封装隐藏了实现细节"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#封装隐藏了实现细节"}},[t._v("#")]),t._v(" 封装隐藏了实现细节")]),t._v(" "),a("p",[t._v("另一个通常与面向对象编程相关的方面是 "),a("strong",[t._v("封装")]),t._v("（"),a("em",[t._v("encapsulation")]),t._v("）的思想：对象的实现细节不能被使用对象的代码获取到。所以唯一与对象交互的方式是通过对象提供的公有 API；使用对象的代码无法深入到对象内部并直接改变数据或者行为。封装使得改变和重构对象的内部时无需改变使用对象的代码。")]),t._v(" "),a("p",[t._v("就像我们在第七章讨论的那样：可以使用 "),a("code",[t._v("pub")]),t._v(" 关键字来决定模块、类型、函数和方法是公有的，而默认情况下其他一切都是私有的。比如，我们可以定义一个包含一个 "),a("code",[t._v("i32")]),t._v(" 类型 vector 的结构体 "),a("code",[t._v("AveragedCollection")]),t._v("。结构体也可以有一个字段，该字段保存了 vector 中所有值的平均值。这样，希望知道结构体中的 vector 的平均值的人可以随时获取它，而无需自己计算。换句话说，"),a("code",[t._v("AveragedCollection")]),t._v(" 会为我们缓存平均值结果。示例 17-1 有 "),a("code",[t._v("AveragedCollection")]),t._v(" 结构体的定义：")]),t._v(" "),a("p",[a("span",{staticClass:"filename"},[t._v("文件名: src/lib.rs")])]),t._v(" "),a("div",{staticClass:"language-rust extra-class"},[a("pre",{pre:!0,attrs:{class:"language-rust"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("pub")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token type-definition class-name"}},[t._v("AveragedCollection")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    list"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Vec")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("i32")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    average"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("f64")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[a("span",{staticClass:"caption"},[t._v("示例 17-1: "),a("code",[t._v("AveragedCollection")]),t._v(" 结构体维护了一个整型列表和集合中所有元素的平均值。")])]),t._v(" "),a("p",[t._v("注意，结构体自身被标记为 "),a("code",[t._v("pub")]),t._v("，这样其他代码就可以使用这个结构体，但是在结构体内部的字段仍然是私有的。这是非常重要的，因为我们希望保证变量被增加到列表或者被从列表删除时，也会同时更新平均值。可以通过在结构体上实现 "),a("code",[t._v("add")]),t._v("、"),a("code",[t._v("remove")]),t._v(" 和 "),a("code",[t._v("average")]),t._v(" 方法来做到这一点，如示例 17-2 所示：")]),t._v(" "),a("p",[a("span",{staticClass:"filename"},[t._v("文件名: src/lib.rs")])]),t._v(" "),a("div",{staticClass:"language-rust extra-class"},[a("pre",{pre:!0,attrs:{class:"language-rust"}},[a("code",[t._v("# "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("pub")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token type-definition class-name"}},[t._v("AveragedCollection")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n#     list"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Vec")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("i32")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n#     average"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("f64")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n# "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("impl")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("AveragedCollection")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("pub")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("fn")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function-definition function"}},[t._v("add")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("mut")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("self")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" value"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("i32")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("self")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("list"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("push")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("value"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("self")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("update_average")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("pub")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("fn")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function-definition function"}},[t._v("remove")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("mut")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("self")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("->")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Option")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("i32")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" result "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("self")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("list"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("pop")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("match")]),t._v(" result "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Some")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("value"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n                "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("self")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("update_average")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n                "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Some")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("value"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("None")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("None")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("pub")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("fn")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function-definition function"}},[t._v("average")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("self")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("->")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("f64")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("self")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("average\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("fn")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function-definition function"}},[t._v("update_average")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("mut")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("self")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" total"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("i32")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("self")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("list"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("iter")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("sum")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("self")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("average "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" total "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("as")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("f64")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("self")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("list"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("len")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("as")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("f64")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[a("span",{staticClass:"caption"},[t._v("示例 17-2: 在"),a("code",[t._v("AveragedCollection")]),t._v(" 结构体上实现了"),a("code",[t._v("add")]),t._v("、"),a("code",[t._v("remove")]),t._v(" 和 "),a("code",[t._v("average")]),t._v(" 公有方法")])]),t._v(" "),a("p",[t._v("公有方法 "),a("code",[t._v("add")]),t._v("、"),a("code",[t._v("remove")]),t._v(" 和 "),a("code",[t._v("average")]),t._v(" 是修改 "),a("code",[t._v("AveragedCollection")]),t._v(" 实例的唯一方式。当使用 "),a("code",[t._v("add")]),t._v(" 方法把一个元素加入到 "),a("code",[t._v("list")]),t._v(" 或者使用 "),a("code",[t._v("remove")]),t._v(" 方法来删除时，这些方法的实现同时会调用私有的 "),a("code",[t._v("update_average")]),t._v(" 方法来更新 "),a("code",[t._v("average")]),t._v(" 字段。")]),t._v(" "),a("p",[a("code",[t._v("list")]),t._v(" 和 "),a("code",[t._v("average")]),t._v(" 是私有的，所以没有其他方式来使得外部的代码直接向 "),a("code",[t._v("list")]),t._v(" 增加或者删除元素，否则 "),a("code",[t._v("list")]),t._v(" 改变时可能会导致 "),a("code",[t._v("average")]),t._v(" 字段不同步。"),a("code",[t._v("average")]),t._v(" 方法返回 "),a("code",[t._v("average")]),t._v(" 字段的值，这使得外部的代码只能读取 "),a("code",[t._v("average")]),t._v(" 而不能修改它。")]),t._v(" "),a("p",[t._v("因为我们已经封装好了 "),a("code",[t._v("AveragedCollection")]),t._v(" 的实现细节，将来可以轻松改变类似数据结构这些方面的内容。例如，可以使用 "),a("code",[t._v("HashSet<i32>")]),t._v(" 代替 "),a("code",[t._v("Vec<i32>")]),t._v(" 作为 "),a("code",[t._v("list")]),t._v(" 字段的类型。只要 "),a("code",[t._v("add")]),t._v("、"),a("code",[t._v("remove")]),t._v(" 和 "),a("code",[t._v("average")]),t._v(" 公有函数的签名保持不变，使用 "),a("code",[t._v("AveragedCollection")]),t._v(" 的代码就无需改变。相反如果使得 "),a("code",[t._v("list")]),t._v(" 为公有，就未必都会如此了： "),a("code",[t._v("HashSet<i32>")]),t._v(" 和 "),a("code",[t._v("Vec<i32>")]),t._v(" 使用不同的方法增加或移除项，所以如果要想直接修改 "),a("code",[t._v("list")]),t._v(" 的话，外部的代码可能不得不做出修改。")]),t._v(" "),a("p",[t._v("如果封装是一个语言被认为是面向对象语言所必要的方面的话，那么 Rust 满足这个要求。在代码中不同的部分使用 "),a("code",[t._v("pub")]),t._v(" 与否可以封装其实现细节。")]),t._v(" "),a("h2",{attrs:{id:"继承，作为类型系统与代码共享"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#继承，作为类型系统与代码共享"}},[t._v("#")]),t._v(" 继承，作为类型系统与代码共享")]),t._v(" "),a("p",[a("strong",[t._v("继承")]),t._v("（"),a("em",[t._v("Inheritance")]),t._v("）是一个很多编程语言都提供的机制，一个对象可以定义为继承另一个对象的定义，这使其可以获得父对象的数据和行为，而无需重新定义。")]),t._v(" "),a("p",[t._v("如果一个语言必须有继承才能被称为面向对象语言的话，那么 Rust 就不是面向对象的。无法定义一个结构体继承父结构体的成员和方法。然而，如果你过去常常在你的编程工具箱使用继承，根据你最初考虑继承的原因，Rust 也提供了其他的解决方案。")]),t._v(" "),a("p",[t._v("选择继承有两个主要的原因。第一个是为了重用代码：一旦为一个类型实现了特定行为，继承可以对一个不同的类型重用这个实现。相反 Rust 代码可以使用默认 trait 方法实现来进行共享，在示例 10-14 中我们见过在 "),a("code",[t._v("Summary")]),t._v(" trait 上增加的 "),a("code",[t._v("summarize")]),t._v(" 方法的默认实现。任何实现了 "),a("code",[t._v("Summary")]),t._v(" trait 的类型都可以使用 "),a("code",[t._v("summarize")]),t._v(" 方法而无须进一步实现。这类似于父类有一个方法的实现，而通过继承子类也拥有这个方法的实现。当实现 "),a("code",[t._v("Summary")]),t._v(" trait 时也可以选择覆盖 "),a("code",[t._v("summarize")]),t._v(" 的默认实现，这类似于子类覆盖从父类继承的方法实现。")]),t._v(" "),a("p",[t._v("第二个使用继承的原因与类型系统有关：表现为子类型可以用于父类型被使用的地方。这也被称为 "),a("strong",[t._v("多态")]),t._v("（"),a("em",[t._v("polymorphism")]),t._v("），这意味着如果多种对象共享特定的属性，则可以相互替代使用。")]),t._v(" "),a("blockquote",[a("p",[t._v("多态（Polymorphism）")]),t._v(" "),a("p",[t._v("很多人将多态描述为继承的同义词。不过它是一个有关可以用于多种类型的代码的更广泛的概念。对于继承来说，这些类型通常是子类。\nRust 则通过泛型来对不同的可能类型进行抽象，并通过 trait bounds 对这些类型所必须提供的内容施加约束。这有时被称为 "),a("em",[t._v("bounded parametric polymorphism")]),t._v("。")])]),t._v(" "),a("p",[t._v("近来继承作为一种语言设计的解决方案在很多语言中失宠了，因为其时常带有共享多于所需的代码的风险。子类不应总是共享其父类的所有特征，但是继承却始终如此。如此会使程序设计更为不灵活，并引入无意义的子类方法调用，或由于方法实际并不适用于子类而造成错误的可能性。某些语言还只允许子类继承一个父类，进一步限制了程序设计的灵活性。")]),t._v(" "),a("p",[t._v("因为这些原因，Rust 选择了一个不同的途径，使用 trait 对象而不是继承。让我们看一下 Rust 中的 trait 对象是如何实现多态的。")])])}),[],!1,null,null,null);s.default=n.exports}}]);