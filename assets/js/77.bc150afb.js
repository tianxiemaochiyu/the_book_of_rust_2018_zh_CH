(window.webpackJsonp=window.webpackJsonp||[]).push([[77],{555:function(s,t,n){"use strict";n.r(t);var a=n(4),e=Object(a.a)({},(function(){var s=this,t=s.$createElement,n=s._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[n("h2",{attrs:{id:"改进-i-o-项目"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#改进-i-o-项目"}},[s._v("#")]),s._v(" 改进 I/O 项目")]),s._v(" "),n("blockquote",[n("p",[n("a",{attrs:{href:"https://github.com/rust-lang/book/blob/master/src/ch13-03-improving-our-io-project.md",target:"_blank",rel:"noopener noreferrer"}},[s._v("ch13-03-improving-our-io-project.md"),n("OutboundLink")],1),s._v(" "),n("br"),s._v("\ncommit 6555fb6c805fbfe7d0961980991f8bca6918928f")])]),s._v(" "),n("p",[s._v("有了这些关于迭代器的新知识，我们可以使用迭代器来改进第十二章中 I/O 项目的实现来使得代码更简洁明了。让我们看看迭代器如何能够改进 "),n("code",[s._v("Config::new")]),s._v(" 函数和 "),n("code",[s._v("search")]),s._v(" 函数的实现。")]),s._v(" "),n("h3",{attrs:{id:"使用迭代器并去掉-clone"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#使用迭代器并去掉-clone"}},[s._v("#")]),s._v(" 使用迭代器并去掉 "),n("code",[s._v("clone")])]),s._v(" "),n("p",[s._v("在示例 12-6 中，我们增加了一些代码获取一个 "),n("code",[s._v("String")]),s._v(" slice 并创建一个 "),n("code",[s._v("Config")]),s._v(" 结构体的实例，他们索引 slice 中的值并克隆这些值以便 "),n("code",[s._v("Config")]),s._v(" 结构体可以拥有这些值。在示例 13-24 中重现了第十二章结尾示例 12-23 中 "),n("code",[s._v("Config::new")]),s._v(" 函数的实现：")]),s._v(" "),n("p",[n("span",{staticClass:"filename"},[s._v("文件名: src/lib.rs")])]),s._v(" "),n("div",{staticClass:"language-rust,ignore extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v('impl Config {\n    pub fn new(args: &[String]) -> Result<Config, &\'static str> {\n        if args.len() < 3 {\n            return Err("not enough arguments");\n        }\n\n        let query = args[1].clone();\n        let filename = args[2].clone();\n\n        let case_sensitive = env::var("CASE_INSENSITIVE").is_err();\n\n        Ok(Config { query, filename, case_sensitive })\n    }\n}\n')])])]),n("p",[n("span",{staticClass:"caption"},[s._v("示例 13-24：重现第十二章结尾的 "),n("code",[s._v("Config::new")]),s._v(" 函数")])]),s._v(" "),n("p",[s._v("那时我们说过不必担心低效的 "),n("code",[s._v("clone")]),s._v(" 调用了，因为将来可以对他们进行改进。好吧，就是现在！")]),s._v(" "),n("p",[s._v("起初这里需要 "),n("code",[s._v("clone")]),s._v(" 的原因是参数 "),n("code",[s._v("args")]),s._v(" 中有一个 "),n("code",[s._v("String")]),s._v(" 元素的 slice，而 "),n("code",[s._v("new")]),s._v(" 函数并不拥有 "),n("code",[s._v("args")]),s._v("。为了能够返回 "),n("code",[s._v("Config")]),s._v(" 实例的所有权，我们需要克隆 "),n("code",[s._v("Config")]),s._v(" 中字段 "),n("code",[s._v("query")]),s._v(" 和 "),n("code",[s._v("filename")]),s._v(" 的值，这样 "),n("code",[s._v("Config")]),s._v(" 实例就能拥有这些值。")]),s._v(" "),n("p",[s._v("在学习了迭代器之后，我们可以将 "),n("code",[s._v("new")]),s._v(" 函数改为获取一个有所有权的迭代器作为参数而不是借用 slice。我们将使用迭代器功能之前检查 slice 长度和索引特定位置的代码。这会明确 "),n("code",[s._v("Config::new")]),s._v(" 的工作因为迭代器会负责访问这些值。")]),s._v(" "),n("p",[s._v("一旦 "),n("code",[s._v("Config::new")]),s._v(" 获取了迭代器的所有权并不再使用借用的索引操作，就可以将迭代器中的 "),n("code",[s._v("String")]),s._v(" 值移动到 "),n("code",[s._v("Config")]),s._v(" 中，而不是调用 "),n("code",[s._v("clone")]),s._v(" 分配新的空间。")]),s._v(" "),n("h4",{attrs:{id:"直接使用-env-args-返回的迭代器"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#直接使用-env-args-返回的迭代器"}},[s._v("#")]),s._v(" 直接使用 "),n("code",[s._v("env::args")]),s._v(" 返回的迭代器")]),s._v(" "),n("p",[s._v("打开 I/O 项目的 "),n("em",[s._v("src/main.rs")]),s._v(" 文件，它看起来应该像这样：")]),s._v(" "),n("p",[n("span",{staticClass:"filename"},[s._v("文件名: src/main.rs")])]),s._v(" "),n("div",{staticClass:"language-rust,ignore extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v('fn main() {\n    let args: Vec<String> = env::args().collect();\n\n    let config = Config::new(&args).unwrap_or_else(|err| {\n        eprintln!("Problem parsing arguments: {}", err);\n        process::exit(1);\n    });\n\n    // --snip--\n}\n')])])]),n("p",[s._v("修改第十二章结尾示例 12-24 中的 "),n("code",[s._v("main")]),s._v(" 函数的开头为示例 13-25 中的代码。在更新 "),n("code",[s._v("Config::new")]),s._v(" 之前这些代码还不能编译：")]),s._v(" "),n("p",[n("span",{staticClass:"filename"},[s._v("文件名: src/main.rs")])]),s._v(" "),n("div",{staticClass:"language-rust,ignore extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v('fn main() {\n    let config = Config::new(env::args()).unwrap_or_else(|err| {\n        eprintln!("Problem parsing arguments: {}", err);\n        process::exit(1);\n    });\n\n    // --snip--\n}\n')])])]),n("p",[n("span",{staticClass:"caption"},[s._v("示例 13-25：将 "),n("code",[s._v("env::args")]),s._v(" 的返回值传递给 "),n("code",[s._v("Config::new")])])]),s._v(" "),n("p",[n("code",[s._v("env::args")]),s._v(" 函数返回一个迭代器！不同于将迭代器的值收集到一个 vector 中接着传递一个 slice 给 "),n("code",[s._v("Config::new")]),s._v("，现在我们直接将 "),n("code",[s._v("env::args")]),s._v(" 返回的迭代器的所有权传递给 "),n("code",[s._v("Config::new")]),s._v("。")]),s._v(" "),n("p",[s._v("接下来需要更新 "),n("code",[s._v("Config::new")]),s._v(" 的定义。在 I/O 项目的 "),n("em",[s._v("src/lib.rs")]),s._v(" 中，将 "),n("code",[s._v("Config::new")]),s._v(" 的签名改为如示例 13-26 所示。这仍然不能编译因为我们还需更新函数体：")]),s._v(" "),n("p",[n("span",{staticClass:"filename"},[s._v("文件名: src/lib.rs")])]),s._v(" "),n("div",{staticClass:"language-rust,ignore extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("impl Config {\n    pub fn new(mut args: std::env::Args) -> Result<Config, &'static str> {\n        // --snip--\n")])])]),n("p",[n("span",{staticClass:"caption"},[s._v("示例 13-26：以迭代器作为参数更新 "),n("code",[s._v("Config::new")]),s._v(" 的签名")])]),s._v(" "),n("p",[n("code",[s._v("env::args")]),s._v(" 函数的标准库文档显示，它返回的迭代器的类型为 "),n("code",[s._v("std::env::Args")]),s._v("。我们已经更新了 "),n("code",[s._v("Config :: new")]),s._v(" 函数的签名，因此参数 "),n("code",[s._v("args")]),s._v(" 的类型为 "),n("code",[s._v("std::env::Args")]),s._v(" 而不是 "),n("code",[s._v("＆[String]")]),s._v("。因为我们拥有 "),n("code",[s._v("args")]),s._v(" 的所有权，并且将通过对其进行迭代来改变 "),n("code",[s._v("args")]),s._v(" ，所以我们可以将 "),n("code",[s._v("mut")]),s._v(" 关键字添加到 "),n("code",[s._v("args")]),s._v(" 参数的规范中以使其可变。")]),s._v(" "),n("h4",{attrs:{id:"使用-iterator-trait-代替索引"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#使用-iterator-trait-代替索引"}},[s._v("#")]),s._v(" 使用 "),n("code",[s._v("Iterator")]),s._v(" trait 代替索引")]),s._v(" "),n("p",[s._v("接下来，我们将修改 "),n("code",[s._v("Config::new")]),s._v(" 的内容。标准库文档还提到 "),n("code",[s._v("std::env::Args")]),s._v(" 实现了 "),n("code",[s._v("Iterator")]),s._v(" trait，因此我们知道可以对其调用 "),n("code",[s._v("next")]),s._v(" 方法！示例 13-27 更新了示例 12-23 中的代码，以使用 "),n("code",[s._v("next")]),s._v(" 方法：")]),s._v(" "),n("p",[n("span",{staticClass:"filename"},[s._v("文件名: src/lib.rs")])]),s._v(" "),n("div",{staticClass:"language-rust extra-class"},[n("pre",{pre:!0,attrs:{class:"language-rust"}},[n("code",[s._v("# "),n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("fn")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token function-definition function"}},[s._v("main")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n# "),n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("use")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token namespace"}},[s._v("std"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("::")])]),s._v("env"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n#\n# "),n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("struct")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token type-definition class-name"}},[s._v("Config")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n#     query"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("String")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v("\n#     filename"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("String")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v("\n#     case_sensitive"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("bool")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v("\n# "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n#\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("impl")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Config")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("pub")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("fn")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token function-definition function"}},[s._v("new")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("mut")]),s._v(" args"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token namespace"}},[s._v("std"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("::")]),s._v("env"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("::")])]),n("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Args")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("->")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Result")]),n("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),n("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Config")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[s._v("&")]),n("span",{pre:!0,attrs:{class:"token lifetime-annotation symbol"}},[s._v("'static")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("str")]),n("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n        args"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[s._v("next")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n\n        "),n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("let")]),s._v(" query "),n("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("match")]),s._v(" args"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[s._v("next")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n            "),n("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Some")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("arg"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=>")]),s._v(" arg"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v("\n            "),n("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("None")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=>")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("return")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Err")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),n("span",{pre:!0,attrs:{class:"token string"}},[s._v('"Didn\'t get a query string"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v("\n        "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n\n        "),n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("let")]),s._v(" filename "),n("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("match")]),s._v(" args"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[s._v("next")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n            "),n("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Some")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("arg"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=>")]),s._v(" arg"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v("\n            "),n("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("None")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=>")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("return")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Err")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),n("span",{pre:!0,attrs:{class:"token string"}},[s._v('"Didn\'t get a file name"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v("\n        "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n\n        "),n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("let")]),s._v(" case_sensitive "),n("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token namespace"}},[s._v("env"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("::")])]),n("span",{pre:!0,attrs:{class:"token function"}},[s._v("var")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),n("span",{pre:!0,attrs:{class:"token string"}},[s._v('"CASE_INSENSITIVE"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[s._v("is_err")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n\n        "),n("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Ok")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),n("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Config")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v(" query"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" filename"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" case_sensitive "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n    "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n")])])]),n("p",[n("span",{staticClass:"caption"},[s._v("示例 13-27：修改 "),n("code",[s._v("Config::new")]),s._v(" 的函数体来使用迭代器方法")])]),s._v(" "),n("p",[s._v("请记住 "),n("code",[s._v("env::args")]),s._v(" 返回值的第一个值是程序的名称。我们希望忽略它并获取下一个值，所以首先调用 "),n("code",[s._v("next")]),s._v(" 并不对返回值做任何操作。之后对希望放入 "),n("code",[s._v("Config")]),s._v(" 中字段 "),n("code",[s._v("query")]),s._v(" 调用 "),n("code",[s._v("next")]),s._v("。如果 "),n("code",[s._v("next")]),s._v(" 返回 "),n("code",[s._v("Some")]),s._v("，使用 "),n("code",[s._v("match")]),s._v(" 来提取其值。如果它返回 "),n("code",[s._v("None")]),s._v("，则意味着没有提供足够的参数并通过 "),n("code",[s._v("Err")]),s._v(" 值提早返回。对 "),n("code",[s._v("filename")]),s._v(" 值进行同样的操作。")]),s._v(" "),n("h3",{attrs:{id:"使用迭代器适配器来使代码更简明"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#使用迭代器适配器来使代码更简明"}},[s._v("#")]),s._v(" 使用迭代器适配器来使代码更简明")]),s._v(" "),n("p",[s._v("I/O 项目中其他可以利用迭代器的地方是 "),n("code",[s._v("search")]),s._v(" 函数，示例 13-28 中重现了第十二章结尾示例 12-19 中此函数的定义：")]),s._v(" "),n("p",[n("span",{staticClass:"filename"},[s._v("文件名: src/lib.rs")])]),s._v(" "),n("div",{staticClass:"language-rust,ignore extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {\n    let mut results = Vec::new();\n\n    for line in contents.lines() {\n        if line.contains(query) {\n            results.push(line);\n        }\n    }\n\n    results\n}\n")])])]),n("p",[n("span",{staticClass:"caption"},[s._v("示例 13-28：示例 12-19 中 "),n("code",[s._v("search")]),s._v(" 函数的定义")])]),s._v(" "),n("p",[s._v("可以通过使用迭代器适配器方法来编写更简明的代码。这也避免了一个可变的中间 "),n("code",[s._v("results")]),s._v(" vector 的使用。函数式编程风格倾向于最小化可变状态的数量来使代码更简洁。去掉可变状态可能会使得将来进行并行搜索的增强变得更容易，因为我们不必管理 "),n("code",[s._v("results")]),s._v(" vector 的并发访问。示例 13-29 展示了该变化：")]),s._v(" "),n("p",[n("span",{staticClass:"filename"},[s._v("文件名: src/lib.rs")])]),s._v(" "),n("div",{staticClass:"language-rust,ignore extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {\n    contents.lines()\n        .filter(|line| line.contains(query))\n        .collect()\n}\n")])])]),n("p",[n("span",{staticClass:"caption"},[s._v("示例 13-29：在 "),n("code",[s._v("search")]),s._v(" 函数实现中使用迭代器适配器")])]),s._v(" "),n("p",[s._v("回忆 "),n("code",[s._v("search")]),s._v(" 函数的目的是返回所有 "),n("code",[s._v("contents")]),s._v(" 中包含 "),n("code",[s._v("query")]),s._v(" 的行。类似于示例 13-19 中的 "),n("code",[s._v("filter")]),s._v(" 例子，可以使用 "),n("code",[s._v("filter")]),s._v(" 适配器只保留 "),n("code",[s._v("line.contains(query)")]),s._v(" 返回 "),n("code",[s._v("true")]),s._v(" 的那些行。接着使用 "),n("code",[s._v("collect")]),s._v(" 将匹配行收集到另一个 vector 中。这样就容易多了！尝试对 "),n("code",[s._v("search_case_insensitive")]),s._v(" 函数做出同样的使用迭代器方法的修改吧。")]),s._v(" "),n("p",[s._v("接下来的逻辑问题就是在代码中应该选择哪种风格：是使用示例 13-28 中的原始实现还是使用示例 13-29 中使用迭代器的版本？大部分 Rust 程序员倾向于使用迭代器风格。开始这有点难以理解，不过一旦你对不同迭代器的工作方式有了感觉之后，迭代器可能会更容易理解。相比摆弄不同的循环并创建新 vector，（迭代器）代码则更关注循环的目的。这抽象掉那些老生常谈的代码，这样就更容易看清代码所特有的概念，比如迭代器中每个元素必须面对的过滤条件。")]),s._v(" "),n("p",[s._v("不过这两种实现真的完全等同吗？直觉上的假设是更底层的循环会更快一些。让我们聊聊性能吧。")])])}),[],!1,null,null,null);t.default=e.exports}}]);