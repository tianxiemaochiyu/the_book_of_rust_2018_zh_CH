(window.webpackJsonp=window.webpackJsonp||[]).push([[101],{580:function(t,e,r){"use strict";r.r(e);var _=r(4),v=Object(_.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"模式用来匹配值的结构"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#模式用来匹配值的结构"}},[t._v("#")]),t._v(" 模式用来匹配值的结构")]),t._v(" "),r("blockquote",[r("p",[r("a",{attrs:{href:"https://github.com/rust-lang/book/blob/master/src/ch18-00-patterns.md",target:"_blank",rel:"noopener noreferrer"}},[t._v("ch18-00-patterns.md"),r("OutboundLink")],1),t._v(" "),r("br"),t._v("\ncommit 1fedfc4b96c2017f64ecfcf41a0a07e2e815f24f")])]),t._v(" "),r("p",[t._v("模式是 Rust 中特殊的语法，它用来匹配类型中的结构，无论类型是简单还是复杂。结合使用模式和 "),r("code",[t._v("match")]),t._v(" 表达式以及其他结构可以提供更多对程序控制流的支配权。模式由如下一些内容组合而成：")]),t._v(" "),r("ul",[r("li",[t._v("字面值")]),t._v(" "),r("li",[t._v("解构的数组、枚举、结构体或者元组")]),t._v(" "),r("li",[t._v("变量")]),t._v(" "),r("li",[t._v("通配符")]),t._v(" "),r("li",[t._v("占位符")])]),t._v(" "),r("p",[t._v("这些部分描述了我们要处理的数据的形状，接着可以用其匹配值来决定程序是否拥有正确的数据来运行特定部分的代码。")]),t._v(" "),r("p",[t._v("我们通过将一些值与模式相比较来使用它。如果模式匹配这些值，我们对值部分进行相应处理。回忆一下第六章讨论 "),r("code",[t._v("match")]),t._v(" 表达式时像硬币分类器那样使用模式。如果数据符合这个形状，就可以使用这些命名的片段。如果不符合，与该模式相关的代码则不会运行。")]),t._v(" "),r("p",[t._v("本章是所有模式相关内容的参考。我们将涉及到使用模式的有效位置，"),r("em",[t._v("refutable")]),t._v(" 与 "),r("em",[t._v("irrefutable")]),t._v(" 模式的区别，和你可能会见到的不同类型的模式语法。在最后，你将会看到如何使用模式创建强大而简洁的代码。")])])}),[],!1,null,null,null);e.default=v.exports}}]);