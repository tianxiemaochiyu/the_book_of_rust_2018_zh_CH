(window.webpackJsonp=window.webpackJsonp||[]).push([[80],{559:function(e,t,a){"use strict";a.r(t);var s=a(4),v=Object(s.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h2",{attrs:{id:"采用发布配置自定义构建"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#采用发布配置自定义构建"}},[e._v("#")]),e._v(" 采用发布配置自定义构建")]),e._v(" "),a("blockquote",[a("p",[a("a",{attrs:{href:"https://github.com/rust-lang/book/blob/master/src/ch14-01-release-profiles.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("ch14-01-release-profiles.md"),a("OutboundLink")],1),e._v(" "),a("br"),e._v("\ncommit 0f10093ac5fbd57feb2352e08ee6d3efd66f887c")])]),e._v(" "),a("p",[e._v("在 Rust 中 "),a("strong",[e._v("发布配置")]),e._v("（"),a("em",[e._v("release profiles")]),e._v("）是预定义的、可定制的带有不同选项的配置，他们允许程序员更灵活地控制代码编译的多种选项。每一个配置都彼此相互独立。")]),e._v(" "),a("p",[e._v("Cargo 有两个主要的配置：运行 "),a("code",[e._v("cargo build")]),e._v(" 时采用的 "),a("code",[e._v("dev")]),e._v(" 配置和运行 "),a("code",[e._v("cargo build --release")]),e._v(" 的 "),a("code",[e._v("release")]),e._v(" 配置。"),a("code",[e._v("dev")]),e._v(" 配置被定义为开发时的好的默认配置，"),a("code",[e._v("release")]),e._v(" 配置则有着良好的发布构建的默认配置。")]),e._v(" "),a("p",[e._v("这些配置名称可能很眼熟，因为它们出现在构建的输出中：")]),e._v(" "),a("div",{staticClass:"language-text extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("$ cargo build\n    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs\n$ cargo build --release\n    Finished release [optimized] target(s) in 0.0 secs\n")])])]),a("p",[e._v("构建输出中的 "),a("code",[e._v("dev")]),e._v(" 和 "),a("code",[e._v("release")]),e._v(" 表明编译器在使用不同的配置。")]),e._v(" "),a("p",[e._v("当项目的 "),a("em",[e._v("Cargo.toml")]),e._v(" 文件中没有任何 "),a("code",[e._v("[profile.*]")]),e._v(" 部分的时候，Cargo 会对每一个配置都采用默认设置。通过增加任何希望定制的配置对应的 "),a("code",[e._v("[profile.*]")]),e._v(" 部分，我们可以选择覆盖任意默认设置的子集。例如，如下是 "),a("code",[e._v("dev")]),e._v(" 和 "),a("code",[e._v("release")]),e._v(" 配置的 "),a("code",[e._v("opt-level")]),e._v(" 设置的默认值：")]),e._v(" "),a("p",[a("span",{staticClass:"filename"},[e._v("文件名: Cargo.toml")])]),e._v(" "),a("div",{staticClass:"language-toml extra-class"},[a("pre",{pre:!0,attrs:{class:"language-toml"}},[a("code",[a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),a("span",{pre:!0,attrs:{class:"token table class-name"}},[e._v("profile.dev")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token key property"}},[e._v("opt-level")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("=")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("0")]),e._v("\n\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),a("span",{pre:!0,attrs:{class:"token table class-name"}},[e._v("profile.release")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token key property"}},[e._v("opt-level")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("=")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("3")]),e._v("\n")])])]),a("p",[a("code",[e._v("opt-level")]),e._v(" 设置控制 Rust 会对代码进行何种程度的优化。这个配置的值从 0 到 3。越高的优化级别需要更多的时间编译，所以如果你在进行开发并经常编译，可能会希望在牺牲一些代码性能的情况下编译得快一些。这就是为什么 "),a("code",[e._v("dev")]),e._v(" 的 "),a("code",[e._v("opt-level")]),e._v(" 默认为 "),a("code",[e._v("0")]),e._v("。当你准备发布时，花费更多时间在编译上则更好。只需要在发布模式编译一次，而编译出来的程序则会运行很多次，所以发布模式用更长的编译时间换取运行更快的代码。这正是为什么 "),a("code",[e._v("release")]),e._v(" 配置的 "),a("code",[e._v("opt-level")]),e._v(" 默认为 "),a("code",[e._v("3")]),e._v("。")]),e._v(" "),a("p",[e._v("我们可以选择通过在 "),a("em",[e._v("Cargo.toml")]),e._v(" 增加不同的值来覆盖任何默认设置。比如，如果我们想要在开发配置中使用级别 1 的优化，则可以在 "),a("em",[e._v("Cargo.toml")]),e._v(" 中增加这两行：")]),e._v(" "),a("p",[a("span",{staticClass:"filename"},[e._v("文件名: Cargo.toml")])]),e._v(" "),a("div",{staticClass:"language-toml extra-class"},[a("pre",{pre:!0,attrs:{class:"language-toml"}},[a("code",[a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),a("span",{pre:!0,attrs:{class:"token table class-name"}},[e._v("profile.dev")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token key property"}},[e._v("opt-level")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("=")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("1")]),e._v("\n")])])]),a("p",[e._v("这会覆盖默认的设置 "),a("code",[e._v("0")]),e._v("。现在运行 "),a("code",[e._v("cargo build")]),e._v(" 时，Cargo 将会使用 "),a("code",[e._v("dev")]),e._v(" 的默认配置加上定制的 "),a("code",[e._v("opt-level")]),e._v("。因为 "),a("code",[e._v("opt-level")]),e._v(" 设置为 "),a("code",[e._v("1")]),e._v("，Cargo 会比默认进行更多的优化，但是没有发布构建那么多。")]),e._v(" "),a("p",[e._v("对于每个配置的设置和其默认值的完整列表，请查看 "),a("a",{attrs:{href:"https://doc.rust-lang.org/cargo/reference/manifest.html#the-profile-sections",target:"_blank",rel:"noopener noreferrer"}},[e._v("Cargo 的文档"),a("OutboundLink")],1),e._v("。")])])}),[],!1,null,null,null);t.default=v.exports}}]);