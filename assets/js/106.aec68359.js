(window.webpackJsonp=window.webpackJsonp||[]).push([[106],{453:function(e,r,t){"use strict";t.r(r);var s=t(42),v=Object(s.a)({},(function(){var e=this,r=e.$createElement,t=e._self._c||r;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"最后的项目-构建多线程-web-server"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#最后的项目-构建多线程-web-server"}},[e._v("#")]),e._v(" 最后的项目: 构建多线程 web server")]),e._v(" "),t("blockquote",[t("p",[t("a",{attrs:{href:"https://github.com/rust-lang/book/blob/master/src/ch20-00-final-project-a-web-server.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("ch20-00-final-project-a-web-server.md"),t("OutboundLink")],1),e._v(" "),t("br"),e._v("\ncommit c084bdd9ee328e7e774df19882ccc139532e53d8")])]),e._v(" "),t("p",[e._v("这是一次漫长的旅途，不过我们到达了本书的结束。在本章中，我们将一同构建另一个项目，来展示最后几章所学，同时复习更早的章节。")]),e._v(" "),t("p",[e._v("作为最后的项目，我们将要实现一个返回 “hello” 的 web server，它在浏览器中看起来就如图例 20-1 所示：")]),e._v(" "),t("p",[t("img",{attrs:{src:"img/trpl20-01.png",alt:"hello from rust"}})]),e._v(" "),t("p",[t("span",{staticClass:"caption"},[e._v("图例 20-1: 我们最后将一起分享的项目")])]),e._v(" "),t("p",[e._v("如下是我们将怎样构建此 web server 的计划：")]),e._v(" "),t("ol",[t("li",[e._v("学习一些 TCP 与 HTTP 知识")]),e._v(" "),t("li",[e._v("在套接字（socket）上监听 TCP 请求")]),e._v(" "),t("li",[e._v("解析少量的 HTTP 请求")]),e._v(" "),t("li",[e._v("创建一个合适的 HTTP 响应")]),e._v(" "),t("li",[e._v("通过线程池改善 server 的吞吐量")])]),e._v(" "),t("p",[e._v("不过在开始之前，需要提到一点细节：这里使用的方法并不是使用 Rust 构建 web server 最好的方法。"),t("a",{attrs:{href:"https://crates.io/",target:"_blank",rel:"noopener noreferrer"}},[e._v("crates.io"),t("OutboundLink")],1),e._v(" 上有很多可用于生产环境的 crate，它们提供了比我们所要编写的更为完整的 web server 和线程池实现。")]),e._v(" "),t("p",[e._v("然而，本章的目的在于学习，而不是走捷径。因为 Rust 是一个系统编程语言，我们能够选择处理什么层次的抽象，并能够选择比其他语言可能或可用的层次更低的层次。因此我们将自己编写一个基础的 HTTP server 和线程池，以便学习将来可能用到的 crate 背后的通用理念和技术。")])])}),[],!1,null,null,null);r.default=v.exports}}]);