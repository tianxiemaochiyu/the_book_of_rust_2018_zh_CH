(window.webpackJsonp=window.webpackJsonp||[]).push([[79],{427:function(r,t,e){"use strict";e.r(t);var o=e(42),a=Object(o.a)({},(function(){var r=this,t=r.$createElement,e=r._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[e("h2",{attrs:{id:"cargo-自定义扩展命令"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#cargo-自定义扩展命令"}},[r._v("#")]),r._v(" Cargo 自定义扩展命令")]),r._v(" "),e("blockquote",[e("p",[e("a",{attrs:{href:"https://github.com/rust-lang/book/blob/master/src/ch14-05-extending-cargo.md",target:"_blank",rel:"noopener noreferrer"}},[r._v("ch14-05-extending-cargo.md"),e("OutboundLink")],1),r._v(" "),e("br"),r._v("\ncommit c084bdd9ee328e7e774df19882ccc139532e53d8")])]),r._v(" "),e("p",[r._v("Cargo 的设计使得开发者可以通过新的子命令来对 Cargo 进行扩展，而无需修改 Cargo 本身。如果 "),e("code",[r._v("$PATH")]),r._v(" 中有类似 "),e("code",[r._v("cargo-something")]),r._v(" 的二进制文件，就可以通过 "),e("code",[r._v("cargo something")]),r._v(" 来像 Cargo 子命令一样运行它。像这样的自定义命令也可以运行 "),e("code",[r._v("cargo --list")]),r._v(" 来展示出来。能够通过 "),e("code",[r._v("cargo install")]),r._v(" 向 Cargo 安装扩展并可以如内建 Cargo 工具那样运行他们是 Cargo 设计上的一个非常方便的优点！")]),r._v(" "),e("h2",{attrs:{id:"总结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[r._v("#")]),r._v(" 总结")]),r._v(" "),e("p",[r._v("通过 Cargo 和 "),e("a",{attrs:{href:"https://crates.io/",target:"_blank",rel:"noopener noreferrer"}},[r._v("crates.io"),e("OutboundLink")],1),r._v(" 来分享代码是使得 Rust 生态环境可以用于许多不同的任务的重要组成部分。Rust 的标准库是小而稳定的，不过 crate 易于分享和使用，并采用一个不同语言自身的时间线来提供改进。不要羞于在 "),e("a",{attrs:{href:"https://crates.io/",target:"_blank",rel:"noopener noreferrer"}},[r._v("crates.io"),e("OutboundLink")],1),r._v(" 上共享对你有用的代码；因为它很有可能对别人也很有用！")])])}),[],!1,null,null,null);t.default=a.exports}}]);